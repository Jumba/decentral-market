\documentclass[]{article}
\usepackage[utf8]{inputenc}
\usepackage{hyperref}

% Itemize with custom spacing
\newenvironment{myitemize}
{ \begin{itemize}
    \setlength{\itemsep}{0pt}
    \setlength{\parskip}{0pt}
    \setlength{\parsep}{0pt}     }
{ \end{itemize}                  } 

%opening
\title{Tsukiji}
\author{Michael The \and Hugo Reinbergen}

\begin{document}

\maketitle


\section{Related Work}
\begin{tabular}{|c|c|}
 \hline
 Document & Contents  \\
 \hline
 \url{https://tinyurl.com/lrqbb2c} & Reputation \\
 \url{https://tinyurl.com/n3v5jsy} & Dispersion \\
 \url{https://bitcoin.org/bitcoin.pdf} & Bitcoin \\
 \url{http://www.weidai.com/bmoney.txt} & b-money \\
 Mailtje van Pouwelse & Credit Based P2P \\
 Book: Computer Networks & DHT, P2P \\
 \hline
\end{tabular}


\section{Foreword}

\tableofcontents

\section{Summary}

\section{Introduction}

\section{Problem definition}
% and/or problem analysis

\section{Requirements}

The goal of this project is to create a decentralised marketplace.
The basics of a marketplace should work, so users have to be able to trade (virtual) commodities.
The system should be decentralised.
It should scale to thousands of users.
A nice user interface is not a priority, so only command line input is required.

Spoofing of message would of course be a big problem in a trading network.
However, since this is a solved problem, the focus of the project should be on other areas.

It would be nice to ensure the privacy of the users.
In order to achieve this, strong encryption of messages is required.
Further thought is also necessary on what information is exposed.
It would be nice to have a network resistant against hostile takeover.
Having a decentralised system plays a big role in this.
However, other attack vectors could also be possible.
Finally, it would be nice to trade real, verified commodities.
Before we can do this however, the requirements listed above should be satisfied first.


The requirements are summarized in this MoSCoW list: \\

\begin{myitemize}
\item Must
\begin{myitemize}
	\item Place an ask/bid
	\item Trade an ask/bid
    \item Find each other (peer discovery)
    \item Decentralised
    \item Scalable to 1000s of users
    \item Command line input
\end{myitemize}
\item Should
\begin{myitemize}
	\item Anti-spoofing
\end{myitemize}
\item Could
\begin{myitemize}
	\item Nice User Interface
\end{myitemize}
\item Would
\begin{myitemize}
	\item Privacy
	\item Protection against attacks
	\item Trade real commodities (like Bitcoins)
\end{myitemize}
\end{myitemize}

\section{Sprint layout}
The development of Tsukiji followed aspects of the Scrum methodology.

\subsection{Sprint 1: Sockets, broadcasting and protocol definition}
\label{sprint1}
\subsubsection{Broadcasting}
The goal of the first sprint was to create a local simulation of the decentral market using socket connections.
The peers had to be able to communicate with each other.
The options considered for this were approaching a subset and relaying the information of your subset to other subsets and broadcasting your information to the entire network.
The issue that arose with the subset approach was that in a competitive market, someone that is selling an item is not easily motivated to advertise in the name of another seller.
This could lead to certain peers, that are offering an item for sale, to not relay other offers that would endanger the profits of the peer.
This could lead to a disjoint of the network and therefor destroy the communication between certain peers.

Broadcasting does not have this issue.
In broadcasting, every peer in the network is directly connected to each other.
Everyone personally takes care of his own advertising and there is no peer between origin and destination that could disrupt the communication.
The issue with broadcasting is that it scales rather poorly.
The increase of data over the network increases exponentially as the amount of users rises.
Because of this, using broadcasting in a large scale project is not advised.
However, broadcasting suffices for the first iteration.
Implementation is simple and it's easily replaced by a more complex system in later sprints.

\subsubsection{Protocol}

In this sprint, the protocol was also defined.
A message formatted as a JSON object is exchanged over TCP.
Each message has 4 required fields:
\begin{myitemize}
\item id: Contains the user's public key. See \ref{sprint1:identifiers} for more information.
\item message-id: Incremented counter unique across messages from one user.
\item timestamp: Time of message creation in UTC in ISO format.
\item type: The type of message.
\end{myitemize}

There are 6 types of messages: ask, bid, trade, confirm, cancel, and greeting.
Depending on the type of message, other fields may be required.

An 'ask' is posted when a user wants to buy.
A 'bid' is posted when a user wants to sell.
The following fields are required for an ask or a bid:
\begin{myitemize}
	\item price: Sets the price per quantity.
	\item quantity: The quantity to be traded.
	\item timeout: Expiration time of the offer in UTC in ISO format.
\end{myitemize}

A 'trade' message is sent as a response to an ask or bid message.
The following fields are required for a trade:
\begin{myitemize}
	\item quantity: The quantity to be traded. This may be less than the quantity stated in the ask/bid.
	\item trade-id: Contains the id and message-id of the ask/bid the trade is requested for. This way the receiver knows which ask/bid the trade is requested for.
\end{myitemize}

A 'confirm' or a 'cancel' message is sent as a response to a trade message.
A 'confirm' message confirms the trade.
A 'cancel' message is sent when the ask/bid the trade is requested for no longer exists, either because it is already traded or the user has decided to cancel their ask/bid.
See \ref{sprint1:cancelling} for the motivation behind this design.
The following field is required for a confirm or a cancel:
\begin{myitemize}
\item trade-id: the trade-id of the trade responded to.
\end{myitemize}

A 'greeting' message is sent when a user wants to announce its existence to the network.
This is used later on for peer discovery.
No additional fields are required.

\subsection{Problems and solutions}
\subsubsection{Broken Pipes}
Testing the socket connection showed a couple of issues.
Whenever a client would disconnect from a peer, the server that it was connected to reported a Broken Pipe error.
This however did not stop the server from running but it did add 2 empty string to the collection of received strings.
However if the server received an empty string that was sent intentionally, it ignores that message.
Therefor it would not hinder the communication if the Broken Pipe errors are suppressed, since the program will not change behaviour.
The empty strings that resulted from this error are now filtered out.

\subsubsection{Identifiers}
\label{sprint1:identifiers}
With the lack of a central authority confirming the identity of peers within the network, the users need an identifier of their own that distinguishes them from others.
This id needs to be unique to the peer and needs to be constructed as such that it cannot be imitated by someone else.
A regular username and password structure is not possible in a decentralised network since there is no entity that is trusted to store and confirm the passwords.


Simply using a username without a password is possible by broadcasting a request to receive all the usernames and allowing only nonexistent names to be used during creation.
While this creates a unique identifier for the user, it does not create a safety measure against impostors.
Anyone can declare that his username is Alice and can then validate transactions in the name of Alice, without the consent of the actual real Alice.

A solution to this problem lies in cryptography.
We need a way for users to prove that they are authentic.
Asymmetric encryption provides the solution.
The peers can use their public key as a unique identifier, since the chances of a SHA256 collision happening are incredibly low.
Users can now use the public key of the recipient of their message to force them to authenticate themselves.
As long as everyone stays the sole owner of their private key, no one but themselves will be able to respond correctly to the authentication request.
This enables a network where everyone can read every message, but can only answer to authentication requests when they are the original sender of the message.


\subsubsection{Cancelling}
\label{sprint1:cancelling}
We discussed how to cancel an ask or bid.
Our first proposal was to broadcast a special cancel message to all peers.
However, there are two major problems with this approach: authentication and flooding.


At the time of writing, a public key is used as identifier.
This means the same public key has to be used to send out the cancel message.
A single person should be able to create and dispose of public/private key pairs at will.
If, for whatever reason, the public/private key pair is lost, the ask/bid cannot be cancelled.


Another problem is the spoofing of these cancel messages.
Suppose a malicious third party sends out a cancel message.
Other users in the network cannot act on this message without authenticating the sender.
This would require three messages total.
Suppose Alice wants to send a cancel message to Bob.
The first is the cancel message from Alice to Bob.
The second is Bob asking Alice for verification, e.g.
by sending a random number encrypted by Alice's public key.
The third message would be Alice sending Bob the answer, proving she can decrypt the random number.
This would quickly strain the network.


The solution to both of these problems is to not broadcast a cancel message at all.
If someone requests a trade to a cancelled ask/bid, it is replied to with a cancel message.
A timeout field is also added to every ask/bid.


Suppose Alice wants to cancel her ask/bid.
Internally, she will mark her ask/bid as cancelled.
If Bob requests a trade, Alice responds with a cancel message.
If Bob wants to authenticate Alice, he can piggyback a verification request with the trade message.
In the cancel message Alice responds with, she will also verify her identity with her private key.
This protocol only needs two messages, instead of three.
This exchange only happens between interested parties, instead of the entire network.
Lastly, this only occurs until the time of expiration.

\subsection{Sprint 2: Twisted and peer discovery}

\subsubsection{Twisted}
The self-created networking protocol of sprint 1 showed how the idea of the implementation would work in practice.
What we need now is a stable and well-tested protocol to further our project into scaling and to prepare it for the real deal.
To save us the work required to produce such code, we chose to use a library instead.

Twisted is a open source library that offers many options for networking and communication. 
Their site describes it as an event-based framework for internet applications. Using this framework, rather than our self-made code had a couple of benefits:
\begin{itemize}
\item Twisted is well-tested
\item Twisted is event-driven
\item Twisted is UDP
\item Twisted is already implemented
\end{itemize}
The current implementation of the broadcasting protocol of sprint 1 does not contain any tests so there is no guarantee that the code is bug-free and ready to be extended.
Twisted on the other hand has numerous test cases that cover many use-cases.
Because of this, a lot of time can be saved by trusting that the imported functions of Twisted will behave as promised instead of writing tests for our own implementation.

The current implementation contains and endless loop that continuously polls for messages.
This is a enormous strain on the processor and the overall behaviour of the computer running the program.
Twisted gives a structure that requires a low amount of recourses when it is not handling data for sending or receiving messages with an event-driven engine.

Torrenting networks generally use UDP implementations to transport their data.
To keep in line with this, it would be useful to have a similar way of handling communication in extensions of these programs.
Twisted provides options for both TCP and UDP, so again, it provides a built-in solution.

All the above issues could be made and added to the current TCP implementation made in the previous sprint.
This would however cost a lot of time that could be spent on trying to solve different issues that do not have such an easy outcome. \\
\\
With all these points added up, Twisted seems like a great way to improve the current networking implementation and provide reliability and scalability.
\subsubsection{Peer discovery}
One of the issues of having a decentralised system is that there is no central authority that can provide information about all the users and all the data. 
Because of this, when a peer is not yet part of the network, it has no knowledge of who to contact for more information about the network and all the peers connected to it. 
This problem of peer discovery has not yet been solved in a truly decentralised way. 
The current solution of this protocol is to give a peerlist to the new user. 
This peerlist contains a number of peers that should always be online. 
The new peer then connects with a random one peer of this list. 
This one master-peer then send a list to the new peer of everyone connected to it. 
This is added to the current peerlist of the new peer so the next time it comes online it can try one of the master peers and if they all happen to be taken down, it can also try to contact one of the peers it has once connected to.
With this implementation, the system is still mostly decentralised, but it still requires a number of master-peers to be online to support a first-time connection of new users.
\subsubsection{Gossip}
The implementation of sprint 1 used the broadcasting protocol to bring information of one peer to all the other peers.
This protocol is simple to implement but bring the issue of scalability. 
When the network grows larger, every peer has to send to more recipients and there are more peers sending messages in the first place as well.
To increase the scalability, a better protocol is required.\\
\\
The peer discovery discussed in the previous section inherently creates a situation where subgroups of peers are created that know eachother, with those subgroups connected to other groups through a couple of peers that know of other so-called cliques.
This property of the network is exactly what an epidemic or gossip protocol uses.
This type of protocol has a peer relay all the messages it receives to all peers that it has encountered, not every single one peer in the whole network.
Since the peers in a group have randomly chosen who sends them their peerlist, every peer should have a sligtly different group of other peers that it knows.
Even in the cases that every peer only encounters users within its own subgroup, the original master-peers can still act as a bridge between the groups.\\
\\
This way, the network traffic is severely reduced as opposed to a broadcasting protocol.
The addition of a new user now only increases load of one group, rather than every peer in the network and with the addition of many new peers, new groups will form to in turn cut down the overall stress.

% \section{Conclusion}
% \section{Discussion}
% \section{References}

\end{document}
