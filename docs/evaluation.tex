\section{Evaluation}
\label{evaluation}
This section evaluates the project's development process and end product.
Tsukiji will be analysed in terms of code quality and how much requirements have been fulfilled. An overview of known issues will be given at the end.

%3 pages
%Talk about planning, development style
\subsection{Development process}
The planning was to spend 2 weeks researching the given problem and then spend around 6 weeks developing a solution, while documenting the decisions made during those weeks.
This structure was uphold throughout the lifespan of the project.
Documentation began lacking halfway through the project, but this was quickly corrected to make sure every decision was written down as accurately as possible.

Due to the agile development methodology, it was difficult to plan every sprint ahead of time.
Requirements could change and the focus of the project could diverge from the decisions made in the first meeting with the client.
Regardless, the Scrum way of developing proved to be very useful.
Exactly because of the volatile nature of the project, creating additions to the software on a week to week basis fit the project perfectly. 
Decisions made along the way, such as ignoring the possibility of people cheating the system, greatly simplified protocol design without losing time on pre-emptively implementing a structure for such a protocol.

%Communication
A large benefit to the development of Tsukiji was that the team consisted out of two developers.
The advantage this brings is that the team could always work together in the same physical room.
It became very easy to discuss issues and make decisions, such as whether to use a certain library or protocol.
The developers sat next to each other which eliminated any overhead or inaccuracies in communication typical in technologies such as e-mail or instant messaging.
The load of work was divided such that both members were responsible for a certain feature of the software.
Whenever a member finished their implementation for the current sprint, they immediately documented what they had written.

\subsection{Fulfillment of requirements}
\label{requirementsfill}
Section \ref{requirements} discusses the requirements of Tsukiji.
Important in the evaluation of a project is whether it complies with the requirements given by the client.
This section will follow along with the MoSCoW list given in chapter \ref{requirements}, beginning with the 'Must have'-requirements and ending with the 'Would have's.

Every 'Must have'-requirement has been fulfilled by Tsukiji.
Users are able to place offers and respond to offers. 
The response is currently handled by a trading engine that matches the asks with bids, given the same quantity and value.
Apart from a peerlist that is distributed with the software, the system is completely decentralised. 
Every peer can find another peer through the peerlist.
Passing messages happens with the gossip protocol, which does not require a central message-server.
Authentication is done through public and private keys.
This also does not require a central point.
The scalability is tested with a simulation on a single computer.
This test showed that messages can easily be handled in the range of 1000s of users and that duplicate messages are not passed along when received.
More on this can be found in section \ref{sprint3:scalability}
All of these tests were performed in a linux terminal, so the requirement of control through command line input has been fulfilled as well.

The only 'Should have'-requirement has been fulfilled.
Users are able to spend real money (currently any currency supported by PayPal) on the good traded in Tsukiji.
We have chosen not to use BitCoin, for this since real money is not far more stable and is far less likely to suddenly disappear. 
The currency used by the software should not impact the program's ability to make trades
Should BitCoin ever stop existing, then Tsukiji can easily make use of other currencies.

The current implementation fulfils no 'Could have' or 'Would have' requirements.
Implementing a User Interface takes a lot of time without increasing any functionality.
Since Tsukiji is a proof of concept, we wanted to create as much functionality as possible in the time given.
This lead to the decision to focus on other features than a GUI.
Interaction with the program occurs through a terminal.

The 'Would have'-requirements are mainly security issues.
These problems can certainly be solved, but it would require a lot of time to achieve something that is outside the scope of this project.
Tsukiji was created to show that it is possible to create a marketplace without a central authority, it was not created to protect users of an online marketplace from fraud.
While this is certainly a requirement for a functional program to be used by many users, it is still a solved problem.
This issue could be addressed in a future project, using the existing code-base.

The privacy requirement is partly fulfilled.
Users do not have an identifier bound directly to their real identity.
They simply have an MD5 hash sent across the network.
The offers created can be tracked down to the hash, and to the IP that sent the message.
A user could spoof his IP whenever he is creating trades to stay hidden, but this is its own responsibility.
Besides that, a possible privacy breach could be PayPal.
To avoid using ones real account, it is possible to create a new PayPal account on a fake email address and use that to make transactions.
The bank accounts linked to PayPal are not visible in transactions, so the trades will not give away a users identity.

It is clear that all the crucial requirements have been met.
Tsukiji sufficiently fulfils what the client had asked for.

\subsection{Known issues}
\label{knownissues}
The current implementation of Tsukiji has a couple of issues that have not been addressed.
Section \ref{requirementsfill} already touched on a couple of missing features such as perfect anonymity and security.
There is another major factor that is problematic for the current state of the protocol.

Currently, a user can lie about his transactions.
It is possible to pretend to have a certain amount of points for sale, while not actually having any at all.
This is because Alice has no way to check the transactions Bob has made.
Alice would only be able to see that a certain bid or ask is no longer in the list of offers.
If Bob spoofed a message that says that a certain transaction has been made, Alice has no way to verify the truth of that.
This creates a trust-issue that is currently not resolved.
Section \ref{recommendations} provides a possible solution for this problem.

Another known issue of Tsukiji is that it is risky to make a large transaction, since incremental payments (see section 7.5) have not been implemented.
Whenever a user sends someone else money to buy goods, there is no way to force the other party to actually send the goods.
This creates a situation where only small amounts of goods will be traded at once and will quickly clutter the marketplace with many small offers.

We believe it to be feasible to solve these issues, but were unable to within the time frame given for this project.
It would be interesting to extend Tsukiji to support solutions for these issues.
These are the first steps towards transforming this proof of concept to be used a real piece of software.

%trust issues
%security
%anonimization

%Talk about test coverage(picture!) and SIG feedback
\subsection{Code quality}
<<Talk about testing and coverage>>

\subsubsection{Response to first round of SIG feedback}
Aside from our own testing, the code was also sent to the Software Inspection Group at two points during development.
Appendix \ref{SIG} contains their analysis of Tsukiji's code base.
This section will cover our response and how we handled the feedback.

Three points of attention are given in the first feedback: component balance, unit interfacing, and testing.

We agree on the points regarding component balance.
At the time, the code was split up into three main files: orderbook.py, crypto.py, and udpreceive.py.
While the first two files are fairly self-explanatory, udpreceive is fairly ambiguous.
There were also some extraneous components (e.g. udpsend) that were not core to the system, but possibly confusing to newcomers.
In response to this feedback, udpreceive.py was renamed to trader.py.
This more accurately describes what this file stands for.
If you invoke trader.py, you start up a new trader server.
However, we find it difficult to split the remaining parts up into more components.

The second point given talked about unit interfacing.
In this case, we believe SIG's feedback to be correct, but their solution undesirable.
It is true that many functions contain many arguments.
A lot of these shared common functionality, so we have abstracted these further into a main function.
However, SIG's solution is to introduce more classes.
In our project, these classes would be little more than packaging.
Rather than using classes, we use a lot of pure functions that return python dictionaries, and good variable names.
These can be seen as a replacement for classes.
There's a great talk from pycon 2012 called "Stop writing classes" \cite{noclassesvid}.
We believe the principles given in this talk to apply to our situation here.

The final piece of feedback given talked about testing.
We agree completely with this feedback and have since then implemented our own test suite.
The process of creating this test suite is described in section \ref{methodoloy:sprint3}.

\subsubsection{Response to second round of SIG feedback}
The second round of feedback largely matches our response.
We have not adjusted unit interfacing because of the reasons explained previously.
We have not adjusted component balance in a major way.
We have added a lot of test code, which is acknowledged.
For the future course of this project, we will continue to keep a closer look at testing and component balance.
We do not believe unit interfacing poses a problem currently, but it is of course possible that it might in the future.
We will continue to monitor throughout the project's lifespan.